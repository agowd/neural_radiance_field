# -*- coding: utf-8 -*-
"""neural_rendering_project.ipynb

Automatically generated by Colab.

Original file is located at
    <>

## Fitting 2D/3D Scenes Using Neural Radiance Field Positional Encoding

### Part 1: Fitting a 2D Image
"""

import numpy as np
import os
import torch
import torch.nn as nn
import torch.nn.functional as F
import matplotlib.pyplot as plt
import imageio.v2 as imageio
import time
import gdown

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
print(device)

"""We first download the image from the web. We normalize the image so the pixels are in between the range of [0,1]."""

url = "https://drive.google.com/file/d/1rD1aaxN8aSynZ8OPA7EI3G936IF0vcUt/view?usp=sharing"
gdown.download(url=url, output='starry_night.jpg', quiet=False, fuzzy=True)

# Load painting image
painting = imageio.imread("starry_night.jpg")
painting = torch.from_numpy(np.array(painting, dtype=np.float32)/255.).to(device)
height_painting, width_painting = painting.shape[:2]

"""1.1 Complete the function positional_encoding()"""

def positional_encoding(x, num_frequencies=6, incl_input=True):

    """
    Apply positional encoding to the input.

    Args:
    x (torch.Tensor): Input tensor to be positionally encoded.
      The dimension of x is [N, D], where N is the number of input coordinates,
      and D is the dimension of the input coordinate.
    num_frequencies (optional, int): The number of frequencies used in
     the positional encoding (default: 6).
    incl_input (optional, bool): If True, concatenate the input with the
        computed positional encoding (default: True).

    Returns:
    (torch.Tensor): Positional encoding of the input tensor.
    """

    results = []
    if incl_input:
        results.append(x)
    # encode input tensor and append the encoded tensor to the list of results.
    for i in range(num_frequencies):
      results.append(torch.sin((2**i)*np.pi*x))
      results.append(torch.cos((2**i)*np.pi*x))

    return torch.cat(results, dim=-1)

"""1.2 Complete the class model_2d() that will be used to fit the 2D image.

"""

class model_2d(nn.Module):

    """
    Define a 2D model comprising of three fully connected layers,
    two relu activations and one sigmoid activation.
    """

    def __init__(self, filter_size=128, num_frequencies=6):
        super().__init__()

        self.layer_in = nn.Linear(2+2*2*num_frequencies, filter_size)
        self.layer = nn.Linear(filter_size, filter_size)
        self.layer_out = nn.Linear(filter_size, 3)
        self.relu1 = nn.ReLU()
        self.relu2 = nn.ReLU()
        self.sigmoid = nn.Sigmoid()


    def forward(self, x):
        x = self.layer_in(x)
        x = self.relu1(x)
        x = self.layer(x)
        x = self.relu2(x)
        x = self.layer_out(x)
        x = self.sigmoid(x)
        return x

def normalize_coord(height, width, num_frequencies=6):

    """
    Creates the 2D normalized coordinates, and applies positional encoding to them

    Args:
    height (int): Height of the image
    width (int): Width of the image
    num_frequencies (optional, int): The number of frequencies used in
      the positional encoding (default: 6).

    Returns:
    (torch.Tensor): Returns the 2D normalized coordinates after applying positional encoding to them.
    """

    # Create the 2D normalized coordinates, and apply positional encoding to them
    y, x = torch.meshgrid(torch.linspace(0, 1, height), torch.linspace(0, 1, width))
    coordinates = torch.stack([x, y], dim=-1)
    embedded_coordinates = positional_encoding(coordinates, num_frequencies)

    return embedded_coordinates

"""You need to complete 1.1 and 1.2 first before completing the train_2d_model function. Don't forget to transfer the completed functions from 1.1 and 1.2 to the part1.py file and upload it to the autograder.

Fill the gaps in the train_2d_model() function to train the model to fit the 2D image.
"""

def train_2d_model(test_img, num_frequencies, device, model=model_2d, positional_encoding=positional_encoding, show=True):

    # Optimizer parameters
    lr = 5e-4
    iterations = 10000
    height, width = test_img.shape[:2]
    # test_img = test_img.to(device)
    # Number of iters after which stats are displayed
    display = 2000

    # Define the model and initialize its weights.
    model2d = model(num_frequencies=num_frequencies)
    model2d.to(device)

    def weights_init(m):
        if isinstance(m, nn.Linear):
            torch.nn.init.xavier_uniform_(m.weight)

    model2d.apply(weights_init)

    # Define the optimizer
    optimizer = torch.optim.Adam(model2d.parameters(), lr=lr)

    # and loss func
    mse_loss = nn.MSELoss()

    # Seed RNG, for repeatability
    seed = 5670
    torch.manual_seed(seed)
    np.random.seed(seed)

    # Lists to log metrics etc.
    psnrs = []
    iternums = []

    t = time.time()
    t0 = time.time()

    # Create the 2D normalized coordinates, and apply positional encoding to them
    embedded_coordinates = normalize_coord(height, width, num_frequencies)

    for i in range(iterations+1):
        optimizer.zero_grad()
        # Run one iteration
        pred = model2d(embedded_coordinates).to(device)
        pred = pred.view_as(test_img)

        # Compute mean-squared error between the predicted and target images. Backprop!

        # compute mse loss
        loss = mse_loss(pred, test_img)

        # backprop
        loss.backward()

        # step
        optimizer.step()


        # Display images/plots/stats
        if i % display == 0 and show:
            # Calculate psnr
            psnr = 10*torch.log10(1.0/loss)


            print("Iteration %d " % i, "Loss: %.4f " % loss.item(), "PSNR: %.2f" % psnr.item(), \
                "Time: %.2f secs per iter" % ((time.time() - t) / display), "%.2f secs in total" % (time.time() - t0))
            t = time.time()

            psnrs.append(psnr.item())
            iternums.append(i)

            plt.figure(figsize=(13, 4))
            plt.subplot(131)
            plt.imshow(pred.detach().cpu().numpy())
            plt.title(f"Iteration {i}")
            plt.subplot(132)
            plt.imshow(test_img.cpu().numpy())
            plt.title("Target image")
            plt.subplot(133)
            plt.plot(iternums, psnrs)
            plt.title("PSNR")
            plt.show()

    print('Done!')
    torch.save(model2d.state_dict(),'model_2d_' + str(num_frequencies) + 'freq.pt')
    plt.imsave('van_gogh_' + str(num_frequencies) + 'freq.png',pred.detach().cpu().numpy())
    return pred.detach().cpu()

"""Train the model to fit the given image without applying positional encoding to the input, and by applying positional encoding of two different frequencies to the input; L = 2 and L = 6."""

_ = train_2d_model(test_img=painting, num_frequencies=6, device=device)

for i in [0, 2]:
    _ = train_2d_model(test_img=painting, num_frequencies=i, device=device)

"""### Part 2: Fitting a 3D Image"""

import os
import gdown
import numpy as np
import torch
import torch.nn as nn
import matplotlib.pyplot as plt
import torch.nn.functional as F
import time


if torch.cuda.is_available():
    # Set the GPU device, for example, the first one
    device = torch.device("cuda:0")
    torch.cuda.set_device(device)
    print("Using GPU:", torch.cuda.get_device_name(device))
else:
    print("No GPU available")

url = "https://drive.google.com/file/d/13eBK_LWxs4SkruFKH7glKK9jwQU1BkXK/view?usp=sharing"
gdown.download(url=url, output='lego_data.npz', quiet=False, fuzzy=True)

"""Here, we load the data that is comprised by the images, the R and T matrices of each camera position with respect to the world coordinates and the intrinsics parameters K of the camera."""

# Load input images, poses, and intrinsics
data = np.load("lego_data.npz")

# Images
images = data["images"]

# Height and width of each image
height, width = images.shape[1:3]

# Camera extrinsics (poses)
poses = data["poses"]
poses = torch.from_numpy(poses).to(device)
print(poses.shape)

# Camera intrinsics
intrinsics = data["intrinsics"]
intrinsics = torch.from_numpy(intrinsics).to(device)

# Hold one image out (for test).
test_image, test_pose = images[101], poses[101]
test_image = torch.from_numpy(test_image).to(device)

# Map images to device
images = torch.from_numpy(images[:100, ..., :3]).to(device)

plt.imshow(test_image.detach().cpu().numpy())
plt.show()

print(data)

"""2.1 Complete the following function that calculates the rays that pass through all the pixels of an HxW image"""

def get_rays(height, width, intrinsics, w_R_c, w_T_c):

    """
    Compute the origin and direction of rays passing through all pixels of an image (one ray per pixel).

    Args:
    height: the height of an image.
    width: the width of an image.
    intrinsics: camera intrinsics matrix of shape (3, 3).
    w_R_c: Rotation matrix of shape (3,3) from camera to world coordinates.
    w_T_c: Translation vector of shape (3,1) that transforms

    Returns:
    ray_origins (torch.Tensor): A tensor of shape (height, width, 3) denoting the centers of
      each ray. Note that desipte that all ray share the same origin, here we ask you to return
      the ray origin for each ray as (height, width, 3).
    ray_directions (torch.Tensor): A tensor of shape (height, width, 3) denoting the
      direction of each ray.
    """

    device = intrinsics.device
    ray_directions = torch.zeros((height, width, 3), device=device)  # placeholder
    ray_origins = torch.zeros((height, width, 3), device=device)  # placeholder

    u, v = torch.meshgrid(torch.arange(width,dtype=torch.float32), torch.arange(height,dtype=torch.float32))
    u, v = u.flatten(), v.flatten()

    pix = torch.stack((u, v, torch.ones_like(u)))
    pix = pix.to(device)

    cam = torch.inverse(intrinsics) @ pix

    ray_directions = (w_R_c @ cam).T.reshape(height, width, 3).transpose(0, 1)
    ray_origins[:,:] = w_T_c

    return ray_origins, ray_directions

"""2.2 Complete the following function to implement the sampling of points along a given ray."""

def stratified_sampling(ray_origins, ray_directions, near, far, samples):

    """
    Sample 3D points on the given rays. The near and far variables indicate the bounds of sampling range.

    Args:
    ray_origins: Origin of each ray in the "bundle" as returned by the
      get_rays() function. Shape: (height, width, 3).
    ray_directions: Direction of each ray in the "bundle" as returned by the
      get_rays() function. Shape: (height, width, 3).
    near: The 'near' extent of the bounding volume.
    far:  The 'far' extent of the bounding volume.
    samples: Number of samples to be drawn along each ray.

    Returns:
    ray_points: Query 3D points along each ray. Shape: (height, width, samples, 3).
    depth_points: Sampled depth values along each ray. Shape: (height, width, samples).
    """

    H, W, _ = ray_origins.shape

    ray_points = torch.zeros((H, W, samples, 3))
    depth_points = torch.zeros((H, W, samples))

    t = torch.linspace(near, far, samples)

    for i in range(samples):
        ray_points[..., i, :] = ray_origins + t[i] * ray_directions

    depth_points = t.view(1, 1, -1).expand(H, W, samples)



    return ray_points, depth_points

"""2.3 Define the network architecture of NeRF along with a function that divided data into chunks to avoid memory leaks during training."""

class nerf_model(nn.Module):

    """
    Define a NeRF model comprising eight fully connected layers and following the
    architecture described in the NeRF paper.
    """

    def __init__(self, filter_size=256, num_x_frequencies=6, num_d_frequencies=3):
        super().__init__()

        xdim = 3+2*3*num_x_frequencies
        ddim = 3+2*3*num_d_frequencies
        self.layers = nn.ModuleDict({
            'layer_1': nn.Linear(xdim, filter_size),
            'layer_2': nn.Linear(filter_size, filter_size),
            'layer_3': nn.Linear(filter_size, filter_size),
            'layer_4': nn.Linear(filter_size, filter_size),
            'layer_5': nn.Linear(filter_size, filter_size),
            'layer_6': nn.Linear(filter_size+xdim, filter_size),
            'layer_7': nn.Linear(filter_size, filter_size),
            'layer_8': nn.Linear(filter_size, filter_size),
            'layer_s': nn.Linear(filter_size, 1),
            'layer_9': nn.Linear(filter_size, filter_size),
            'layer_10': nn.Linear(filter_size+ddim, filter_size//2),
            'layer_11': nn.Linear(filter_size//2, 3),
        })
        self.relu = nn.ReLU()
        self.sigmoid = nn.Sigmoid()


    def forward(self, x, d):
        x_ = self.relu(self.layers['layer_1'](x))
        x_ = self.relu(self.layers['layer_2'](x_))
        x_ = self.relu(self.layers['layer_3'](x_))
        x_ = self.relu(self.layers['layer_4'](x_))
        x_ = self.relu(self.layers['layer_5'](x_))
        x_ = self.relu(self.layers['layer_6'](torch.cat((x_,x), dim=-1)))
        x_ = self.relu(self.layers['layer_7'](x_))
        x_ = self.relu(self.layers['layer_8'](x_))
        sigma = self.layers['layer_s'](x_)
        x_ = self.layers['layer_9'](x_)
        x_ = self.relu(self.layers['layer_10'](torch.cat((x_,d), dim=-1)))
        rgb = self.sigmoid(self.layers['layer_11'](x_))
        return rgb, sigma

def get_batches(ray_points, ray_directions, num_x_frequencies, num_d_frequencies):

    def get_chunks(inputs, chunksize = 2**15):
        """
        This fuction gets an array/list as input and returns a list of chunks of the initial array/list
        """
        return [inputs[i:i + chunksize] for i in range(0, inputs.shape[0], chunksize)]

    """
    This function returns chunks of the ray points and directions to avoid memory errors with the
    neural network. It also applies positional encoding to the input points and directions before
    dividing them into chunks, as well as normalizing and populating the directions.
    """

    ray_directions /= torch.linalg.norm(ray_directions, dim=-1).unsqueeze(-1)

    ray_directions = ray_directions.unsqueeze(2).expand(-1,-1,ray_points.shape[2],-1)

    ray_points = positional_encoding(ray_points, num_x_frequencies).reshape(-1, 3+2*3*num_x_frequencies)
    ray_directions = positional_encoding(ray_directions, num_d_frequencies).reshape(-1, 3+2*3*num_d_frequencies)

    ray_points_batches, ray_directions_batches = get_chunks(ray_points), get_chunks(ray_directions)

    return ray_points_batches, ray_directions_batches

"""2.4 Compute the compositing weights of samples on camera ray and then complete the volumetric rendering procedure to reconstruct a whole RGB image from the sampled points and the outputs of the neural network."""

def volumetric_rendering(rgb, s, depth_points):

    """
    Differentiably renders a radiance field, given the origin of each ray in the
    "bundle", and the sampled depth values along them.

    Args:
    rgb: RGB color at each query location (X, Y, Z). Shape: (height, width, samples, 3).
    sigma: Volume density at each query location (X, Y, Z). Shape: (height, width, samples).
    depth_points: Sampled depth values along each ray. Shape: (height, width, samples).

    Returns:
    rec_image: The reconstructed image after applying the volumetric rendering to every pixel.
    Shape: (height, width, 3)
    """

    H, W, S, _ = rgb.shape

    rgb = rgb.reshape((H * W, S, 3)).to(device)
    s = s.reshape((H * W, S)).clamp(min=0).to(device)  # ReLU using clamp
    depth_points = depth_points.reshape((H * W, S)).to(device)

    # Calculate delta in a vectorized manner
    delta = torch.cat((torch.diff(depth_points, dim=1).to(device), torch.full((H * W, 1), 10**9).to(device)), dim=1).to(device)

    # Calculate T in a vectorized manner
    T = torch.exp(-1 * torch.cat((torch.zeros((H * W, 1)).to(device), torch.cumsum(s * delta, dim=1)[:, :-1].to(device)), dim=1)).to(device)

    # Calculate rec_image in a vectorized manner
    rec_image = torch.sum((1 - torch.exp(-1 * s * delta)).unsqueeze(2) * T.unsqueeze(2) * rgb, dim=1).to(device)

    # Reshape back to original shape
    rec_image = rec_image.reshape((H, W, 3)).to(device)

    return rec_image

"""To test and visualize your implementation, independently of the previous and next steps of the
NeRF pipeline, you can load the sanity_volumentric.pt file, run your implementation of the volumetric function and expect to see the figure provided in the handout.

"""

url = "https://drive.google.com/file/d/1ag6MqSh3h4KY10Mcx5fKxt9roGNLLILK/view?usp=sharing"
gdown.download(url=url, output='sanity_volumentric.pt', quiet=False, fuzzy=True)
rbd = torch.load('sanity_volumentric.pt')

r = rbd['rgb']
s = rbd['sigma']
depth_points = rbd['depth_points']
rec_image = volumetric_rendering(r, s, depth_points)

plt.figure(figsize=(10, 5))
plt.imshow(rec_image.detach().cpu().numpy())
plt.title(f'Volumentric rendering of a sphere with $\\sigma={0.2}$, on blue background')
plt.show()

"""2.5 Combine everything together. Given the pose position of a camera, compute the camera rays and sample the 3D points along these rays. Divide those points into batches and feed them to the neural network. Concatenate them and use them for the volumetric rendering to reconstructed the final image."""

def one_forward_pass(height, width, intrinsics, pose, near, far, samples, model, num_x_frequencies, num_d_frequencies):


    #compute all the rays from the image
    ray_origins, ray_directions = get_rays(height, width, intrinsics, pose[:3,:3], pose[:3, 3])
    ray_origins, ray_directions = ray_origins.to(device), ray_directions.to(device)
    #sample the points from the rays
    ray_points, depth_points = stratified_sampling(ray_origins, ray_directions, near, far, samples)
    ray_points, depth_points = ray_points.to(device), depth_points.to(device)
    #divide data into batches to avoid memory errors
    ray_points_batches, ray_direction_batches = get_batches(ray_points, ray_directions, num_x_frequencies, num_d_frequencies)
    # ray_points_batches, ray_direction_batches = ray_points_batches.to(device), ray_direction_batches.to(device)
    # forward pass the batches and concatenate the outputs at the end
    rgb = []
    sigma = []
    for pt, dir in zip(ray_points_batches, ray_direction_batches):
        pt, dir = pt.to(device), dir.to(device)
        rgb_, sigma_ = model(pt, dir)
        rgb_, sigma_ = rgb_.to(device), sigma_.to(device)
        rgb.append(rgb_)
        sigma.append(sigma_)
    rgb = torch.cat(rgb, dim=0)
    sigma = torch.cat(sigma, dim=0)



    # Apply volumetric rendering to obtain the reconstructed image
    rgb = rgb.reshape(height, width, samples, 3)
    sigma = sigma.reshape(height, width, samples)
    rec_image = volumetric_rendering(rgb, sigma, depth_points)


    return rec_image

"""If you manage to pass the autograder for all the previous functions, then it is time to train a NeRF! We provide the hyperparameters for you, we initialize the NeRF model and its weights, and we define a couple lists that will be needed to store results."""

num_x_frequencies = 10
num_d_frequencies = 4
learning_rate  = 5e-4
iterations = 3000
samples = 64
display = 25
near = 0.667
far = 2

model = nerf_model(num_x_frequencies=num_x_frequencies,num_d_frequencies=num_d_frequencies).to(device)

def weights_init(m):
    if isinstance(m, torch.nn.Linear):
        torch.nn.init.xavier_uniform_(m.weight)
model.apply(weights_init)

optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)
mse_loss = nn.MSELoss()

psnrs = []
iternums = []

t = time.time()
t0 = time.time()

for i in range(iterations+1):


    #choose randomly a picture for the forward pass
    j = np.random.randint(0, len(images))
    img = images[j].to(device)
    pose = poses[j].to(device)

    # Run one iteration of NeRF and get the rendered RGB image.
    optimizer.zero_grad()

    rec_img = one_forward_pass(height, width, intrinsics, pose, near, far, samples, model, num_x_frequencies, num_d_frequencies).to(device)


    # Compute mean-squared error between the predicted and target images. Backprop!
    loss = mse_loss(rec_img, img)
    loss.backward()
    optimizer.step()




    # Display images/plots/stats
    if i % display == 0:
        with torch.no_grad():
            # Render the held-out view
            test_rec_image = one_forward_pass(height, width, intrinsics, test_pose, near, far, samples, model, num_x_frequencies, num_d_frequencies)
            test_rec_image = test_rec_image.to(device)

        #calculate the loss and the psnr between the original test image and the reconstructed one.
        test_loss = mse_loss(test_rec_image, test_image)
        R = torch.max(test_image)
        psnr = 10*torch.log10(R**2/test_loss)


        print("Iteration %d " % i, "Loss: %.4f " % loss.item(), "PSNR: %.2f " % psnr.item(), \
                "Time: %.2f secs per iter, " % ((time.time() - t) / display), "%.2f mins in total" % ((time.time() - t0)/60))

        t = time.time()
        psnrs.append(psnr.item())
        iternums.append(i)

        plt.figure(figsize=(16, 4))
        plt.subplot(141)
        plt.imshow(test_rec_image.detach().cpu().numpy())
        plt.title(f"Iteration {i}")
        plt.subplot(142)
        plt.imshow(test_image.detach().cpu().numpy())
        plt.title("Target image")
        plt.subplot(143)
        plt.plot(iternums, psnrs)
        plt.title("PSNR")
        plt.show()
        plt.imsave('test_lego_temp.png',test_rec_image.detach().cpu().numpy())
        torch.save(model.state_dict(),'model_nerf_temp.pt')

plt.imsave('test_lego.png',test_rec_image.detach().cpu().numpy())
torch.save(model.state_dict(),'model_nerf.pt')
print('Done!')

